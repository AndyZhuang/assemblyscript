// Generated by dts-bundle v0.7.3
// Dependencies for this module:
//   ../binaryen
//   ../long
//   ../wabt

declare module 'assemblyscript' {
  /**
    * The exported AssemblyScript namespace.
    *
    * <h4>Sub-namespaces</h4>
    * <ul style="margin: 0; padding: 0; list-style: none">
    *   <li class="tsd-kind-module"><span class="tsd-kind-icon" /> {@link assemblyscript/builtins|builtins}</li>
    *   <li class="tsd-kind-module"><span class="tsd-kind-icon" /> {@link assemblyscript/expressions|expressions}</li>
    *   <li class="tsd-kind-module"><span class="tsd-kind-icon" /> {@link assemblyscript/library|library}</li>
    *   <li class="tsd-kind-module"><span class="tsd-kind-icon" /> {@link assemblyscript/reflection|reflection}</li>
    *   <li class="tsd-kind-module"><span class="tsd-kind-icon" /> {@link assemblyscript/statements|statements}</li>
    *   <li class="tsd-kind-module"><span class="tsd-kind-icon" /> {@link assemblyscript/typescript|typescript}</li>
    *   <li class="tsd-kind-module"><span class="tsd-kind-icon" /> {@link assemblyscript/util|util}</li>
    * </ul>
    *
    * @module assemblyscript
    * @preferred
    */ /** */
  import * as builtins from "assemblyscript/builtins";
  import { Compiler, CompilerTarget } from "assemblyscript/compiler";
  import * as expressions from "assemblyscript/expressions";
  import * as library from "assemblyscript/library";
  import Profiler from "assemblyscript/profiler";
  import * as reflection from "assemblyscript/reflection";
  import * as typescript from "assemblyscript/typescript";
  import * as statements from "assemblyscript/statements";
  import * as util from "assemblyscript/util";
  /** AssemblyScript version. */
  export const version: string;
  export { builtins, Compiler, CompilerTarget, expressions, library, Profiler, reflection, statements, typescript, util };
}

declare module 'assemblyscript/builtins' {
  /**
    * Compiler components dealing with built-in functions.
    *
    * Functions exported by this module correspond to the respective built-in functions. Each takes
    * TypeScript AST-objects and compiles them to opcodes directly.
    *
    * @module assemblyscript/builtins
    */ /** */
  import * as binaryen from "binaryen";
  import Compiler from "assemblyscript/compiler";
  import * as reflection from "assemblyscript/reflection";
  import * as typescript from "assemblyscript/typescript";
  /** Tests if the specified function name corresponds to a built-in function. */
  export function isBuiltin(name: string, isGlobalName?: boolean): boolean;
  /** An array of the statically linked runtime function names. */
  export const runtimeNames: string[];
  /** Tests if the specified function name corresponds to a linked runtime function. */
  export function isRuntime(name: string, isGlobalName?: boolean): boolean;
  /** A pair of TypeScript expressions. */
  export interface TypeScriptExpressionPair {
      0: typescript.Expression;
      1: typescript.Expression;
  }
  /** A pair of Binaryen expressions. */
  export interface BinaryenExpressionPair {
      0: binaryen.Expression;
      1: binaryen.Expression;
  }
  /** Compiles a sign-agnostic rotate left operation. */
  export function rotl(compiler: Compiler, nodes: TypeScriptExpressionPair, exprs: BinaryenExpressionPair): binaryen.Expression;
  /** Compiles a sign-agnostic rotate right operation. */
  export function rotr(compiler: Compiler, nodes: TypeScriptExpressionPair, exprs: BinaryenExpressionPair): binaryen.Expression;
  /** Compiles a sign-agnostic count leading zero bits operation. */
  export function clz(compiler: Compiler, node: typescript.Expression, expr: binaryen.Expression): binaryen.Expression;
  /** Compiles a sign-agnostic count tailing zero bits operation. */
  export function ctz(compiler: Compiler, node: typescript.Expression, expr: binaryen.Expression): binaryen.Expression;
  /** Compiles a sign-agnostic count number of one bits operation. */
  export function popcnt(compiler: Compiler, node: typescript.Expression, expr: binaryen.Expression): binaryen.Expression;
  /** Compiles an absolute value operation. */
  export function abs(compiler: Compiler, node: typescript.Expression, expr: binaryen.Expression): binaryen.Expression;
  /** Compiles a ceiling operation. */
  export function ceil(compiler: Compiler, node: typescript.Expression, expr: binaryen.Expression): binaryen.Expression;
  /** Compiles a floor operation. */
  export function floor(compiler: Compiler, node: typescript.Expression, expr: binaryen.Expression): binaryen.Expression;
  /** Compiles a square root operation. */
  export function sqrt(compiler: Compiler, node: typescript.Expression, expr: binaryen.Expression): binaryen.Expression;
  /** Compiles a round to the nearest integer towards zero operation. */
  export function trunc(compiler: Compiler, node: typescript.Expression, expr: binaryen.Expression): binaryen.Expression;
  /** Compiles a round to the nearest integer tied to even operation. */
  export function nearest(compiler: Compiler, node: typescript.Expression, expr: binaryen.Expression): binaryen.Expression;
  /** Compiles a minimum of two floats operation. */
  export function min(compiler: Compiler, nodes: TypeScriptExpressionPair, exprs: BinaryenExpressionPair): binaryen.Expression;
  /** Compiles a maximum of two floats operation. */
  export function max(compiler: Compiler, nodes: TypeScriptExpressionPair, exprs: BinaryenExpressionPair): binaryen.Expression;
  /** Compiles a copysign operation that composes a float from the magnitude of `x` and the sign of `y`. */
  export function copysign(compiler: Compiler, nodes: TypeScriptExpressionPair, exprs: BinaryenExpressionPair): binaryen.Expression;
  /** Compiles a reinterpretation of a float as an int respectively of an int as a float. */
  export function reinterpret(compiler: Compiler, node: typescript.Expression, expr: binaryen.Expression): binaryen.Expression;
  /** Compiles a current memory operation. */
  export function current_memory(compiler: Compiler): binaryen.Expression;
  /** Compiles a grow memory operation. */
  export function grow_memory(compiler: Compiler, node: typescript.Expression, expr: binaryen.Expression): binaryen.Expression;
  /** Compiles an unreachable operation. */
  export function unreachable(compiler: Compiler): binaryen.Expression;
  /** Compiles a load from memory operation. */
  export function load(compiler: Compiler, type: reflection.Type, node: typescript.Expression, expr: binaryen.Expression): binaryen.Expression;
  /** Compiles a store to memory operation. */
  export function store(compiler: Compiler, type: reflection.Type, nodes: TypeScriptExpressionPair, exprs: BinaryenExpressionPair): binaryen.Expression;
  /** Compiles a sizeof operation determining the byte size of a type. */
  export function sizeof(compiler: Compiler, type: reflection.Type): binaryen.Expression;
  /** Compiles an unsafe cast operation casting a value from one type to another. */
  export function unsafe_cast(expr: binaryen.Expression): binaryen.Expression;
  /** Compiles a check for NaN operation. */
  export function isNaN(compiler: Compiler, node: typescript.Expression, expr: binaryen.Expression): binaryen.Expression;
  /** Compiles a check for a finite number operation. */
  export function isFinite(compiler: Compiler, node: typescript.Expression, expr: binaryen.Expression): binaryen.Expression;
}

declare module 'assemblyscript/compiler' {
  import * as binaryen from "binaryen";
  import * as Long from "long";
  import Profiler from "assemblyscript/profiler";
  import * as reflection from "assemblyscript/reflection";
  import * as typescript from "assemblyscript/typescript";
  /** Compiler options. */
  export interface CompilerOptions {
      /** Whether compilation shall be performed in silent mode without writing to console. Defaults to `false`. */
      silent?: boolean;
      /** Specifies the target architecture. Defaults to {@link CompilerTarget.WASM32}. */
      target?: CompilerTarget | "wasm32" | "wasm64";
      /** Whether to disable built-in tree-shaking. Defaults to `false`. */
      noTreeShaking?: boolean;
      /** Whether to disallow implicit type conversions. Defaults to `false`. */
      noImplicitConversion?: boolean;
      /** Whether to exclude the runtime. */
      noRuntime?: boolean;
      /** Runtime functions to export, defaults to 'malloc' and 'free'. */
      exportRuntime?: string[];
  }
  /** Compiler target. */
  export enum CompilerTarget {
      /** 32-bit WebAssembly target using uint pointers. */
      WASM32 = 0,
      /** 64-bit WebAssembly target using ulong pointers. */
      WASM64 = 1,
  }
  /** A static memory segment. */
  export interface CompilerMemorySegment {
      /** Offset in linear memory. */
      offset: Long;
      /** Data in linear memory. */
      buffer: Uint8Array;
  }
  /**
    * The AssemblyScript compiler.
    *
    * Common usage is covered by the static methods {@link Compiler.compileFile} and {@link Compiler.compileString}
    * for convenience. Their diagnostics go to {@link Compiler.lastDiagnostics}.
    */
  export class Compiler {
      /** Diagnostic messages reported by the last invocation of {@link Compiler.compileFile} or {@link Compiler.compileString}. */
      static lastDiagnostics: typescript.Diagnostic[];
      options: CompilerOptions;
      program: typescript.Program;
      checker: typescript.TypeChecker;
      entryFile: typescript.SourceFile;
      libraryFile: typescript.SourceFile;
      diagnostics: typescript.DiagnosticCollection;
      module: binaryen.Module;
      signatures: {
          [key: string]: binaryen.Signature;
      };
      globalInitializers: binaryen.Expression[];
      memoryBase: Long;
      memorySegments: CompilerMemorySegment[];
      target: CompilerTarget;
      profiler: Profiler;
      currentFunction: reflection.Function;
      stringPool: {
          [key: string]: CompilerMemorySegment;
      };
      runtimeExports: string[];
      uintptrType: reflection.Type;
      functionTemplates: {
          [key: string]: reflection.FunctionTemplate;
      };
      classTemplates: {
          [key: string]: reflection.ClassTemplate;
      };
      globals: {
          [key: string]: reflection.Variable;
      };
      functions: {
          [key: string]: reflection.Function;
      };
      classes: {
          [key: string]: reflection.Class;
      };
      enums: {
          [key: string]: reflection.Enum;
      };
      startFunction: reflection.Function;
      startFunctionBody: typescript.Statement[];
      pendingImplementations: {
          [key: string]: reflection.ClassTemplate;
      };
      /**
        * Compiles an AssemblyScript file to WebAssembly.
        * @param filename Entry file name
        * @param options Compiler options
        * @returns Compiled module or `null` if compilation failed. In case of failure, diagnostics are stored in {@link Compiler#diagnostics}.
        */
      static compileFile(filename: string, options?: CompilerOptions): binaryen.Module | null;
      /**
        * Compiles an AssemblyScript string to WebAssembly.
        * @param source Source string
        * @param options Compiler options
        * @param fileName File to use for the entry file
        * @returns Compiled module or `null` if compilation failed. In case of failure, diagnostics are stored in {@link Compiler#diagnostics}.
        */
      static compileString(source: string, options?: CompilerOptions, fileName?: string): binaryen.Module | null;
      /**
        * Compiles a TypeScript program using AssemblyScript syntax to WebAssembly.
        * @param program TypeScript program
        * @param options Compiler options
        * @returns Compiled module or `null` if compilation failed. In case of failure, diagnostics are stored in {@link Compiler#diagnostics}.
        */
      static compileProgram(program: typescript.Program, options?: CompilerOptions): binaryen.Module | null;
      /** Gets the configured byte size of a pointer. `4` when compiling for 32-bit WebAssembly, `8` when compiling for 64-bit WebAssembly. */
      readonly uintptrSize: number;
      /** Gets the size of an array header in bytes. */
      readonly arrayHeaderSize: number;
      /**
        * Constructs a new AssemblyScript compiler.
        * @param program TypeScript program
        * @param options Compiler options
        */
      constructor(program: typescript.Program, options?: CompilerOptions);
      /** Reports a diagnostic message (adds it to {@link Compiler#diagnostics}) and prints it. */
      report(node: typescript.Node, message: typescript.DiagnosticMessage, arg0?: string | number, arg1?: string | number, arg2?: string | number): void;
      /** Mangles a global name (of a function, a class, ...) for use with binaryen. */
      mangleGlobalName(name: string, sourceFile: typescript.SourceFile): string;
      /** Scans over the sources and initializes the reflection structure. */
      initialize(): void;
      /** Gets an existing signature if it exists and otherwise creates it. */
      getOrAddSignature(argumentTypes: reflection.Type[], returnType: reflection.Type): binaryen.Signature;
      /** Initializes the statically linked or imported runtime. */
      initializeRuntime(): void;
      /** Initializes a global variable. */
      initializeGlobal(node: typescript.VariableStatement): void;
      /** Adds a global variable. */
      addGlobal(name: string, type: reflection.Type, mutable: boolean, initializerNode?: typescript.Expression): void;
      /** Creates or, if it already exists, looks up a static string and returns its offset in linear memory. */
      createStaticString(value: string): Long;
      /** Initializes a top-level function. */
      initializeFunction(node: typescript.FunctionDeclaration): reflection.FunctionHandle;
      /** Initializes a class. */
      initializeClass(node: typescript.ClassDeclaration): reflection.ClassHandle;
      /** Initializes a static method. */
      initializeStaticMethod(node: typescript.MethodDeclaration | typescript.GetAccessorDeclaration | typescript.SetAccessorDeclaration): reflection.FunctionHandle;
      /** Initializes an instance method. */
      initializeInstanceMethod(node: typescript.MethodDeclaration | typescript.GetAccessorDeclaration | typescript.SetAccessorDeclaration | typescript.ConstructorDeclaration, parent: reflection.Class): reflection.FunctionHandle;
      /** Initializes an enum. */
      initializeEnum(node: typescript.EnumDeclaration): reflection.Enum;
      /** Compiles the module and its components. */
      compile(): void;
      /** Compiles the start function if either a user-provided start function is or global initializes are present. */
      maybeCompileStartFunction(): void;
      /** Splits an import name possibly separated with a `$` character to a module name and a name. Defaults to `env` as the module name. */
      static splitImportName(name: string): {
          moduleName: string;
          name: string;
      };
      /** Compiles a malloc invocation using the specified byte size. */
      compileMallocInvocation(size: number, clearMemory?: boolean): binaryen.Expression;
      /** Compiles a function. */
      compileFunction(instance: reflection.Function): binaryen.Function | null;
      /** Compiles a class. */
      compileClass(instance: reflection.Class): void;
      /** Amends the current break context when entering a loop, switch or similar. */
      enterBreakContext(): string;
      /** Amends the current break context when leaving a loop, switch or similar. */
      leaveBreakContext(): void;
      /** Textual break label according to the current break context state. */
      readonly currentBreakLabel: string;
      /** Compiles a statement. */
      compileStatement(node: typescript.Statement): binaryen.Statement;
      /** Compiles an expression. */
      compileExpression(node: typescript.Expression, contextualType: reflection.Type, convertToType?: reflection.Type, convertExplicit?: boolean): binaryen.Expression;
      /** Wraps an expression with a conversion where necessary. */
      maybeConvertValue(node: typescript.Expression, expr: binaryen.Expression, fromType: reflection.Type, toType: reflection.Type, explicit: boolean): binaryen.Expression;
      /** Resolves a TypeScript type alias to the root AssemblyScript type where applicable, by symbol. */
      maybeResolveAlias(symbol: typescript.Symbol): typescript.Symbol;
      /** Resolves a TypeScript type to a AssemblyScript type. */
      resolveType(type: typescript.TypeNode, acceptVoid?: boolean, typeArgumentsMap?: reflection.TypeArgumentsMap): reflection.Type | null;
      /** Resolves an identifier or name to the corresponding reflection object. */
      resolveReference(node: typescript.Identifier | typescript.EntityName, filter?: reflection.ObjectFlags): reflection.Object | null;
      /** Resolves a list of type arguments to a type arguments map. */
      resolveTypeArgumentsMap(typeArguments: typescript.NodeArray<typescript.TypeNode> | typescript.TypeNode[], declaration: typescript.FunctionLikeDeclaration | typescript.ClassDeclaration, baseTypeArgumentsMap?: reflection.TypeArgumentsMap): reflection.TypeArgumentsMap;
      /** Computes the binaryen signature identifier of a reflected type. */
      identifierOf(type: reflection.Type): string;
      /** Obtains the signature of the specified reflected function. */
      signatureOf(instance: reflection.Function): binaryen.Signature;
      /** Computes the binaryen type of a reflected type. */
      typeOf(type: reflection.Type): binaryen.Type;
      /** Computes the binaryen opcode category (i32, i64, f32, f64) of a reflected type. */
      categoryOf(type: reflection.Type): binaryen.I32Operations | binaryen.I64Operations | binaryen.F32Operations | binaryen.F64Operations;
      /** Computes the constant value binaryen expression of the specified reflected type. */
      valueOf(type: reflection.Type, value: number | Long): binaryen.Expression;
      debugInfo(): string;
  }
  export { Compiler as default };
}

declare module 'assemblyscript/expressions' {
  /**
    * Compiler components dealing with TypeScript expressions.
    * @module assemblyscript/expressions
    * @preferred
    */ /** */
  export * from "assemblyscript/expressions/arrayliteral";
  export * from "assemblyscript/expressions/as";
  export * from "assemblyscript/expressions/binary";
  export * from "assemblyscript/expressions/call";
  export * from "assemblyscript/expressions/conditional";
  export * from "assemblyscript/expressions/elementaccess";
  export * from "assemblyscript/expressions/helpers/load";
  export * from "assemblyscript/expressions/helpers/loadorstore";
  export * from "assemblyscript/expressions/helpers/store";
  export * from "assemblyscript/expressions/identifier";
  export * from "assemblyscript/expressions/literal";
  export * from "assemblyscript/expressions/new";
  export * from "assemblyscript/expressions/omitted";
  export * from "assemblyscript/expressions/parenthesized";
  export * from "assemblyscript/expressions/postfixunary";
  export * from "assemblyscript/expressions/prefixunary";
  export * from "assemblyscript/expressions/propertyaccess";
  import * as binaryen from "binaryen";
  import Compiler from "assemblyscript/compiler";
  import * as reflection from "assemblyscript/reflection";
  import * as typescript from "assemblyscript/typescript";
  /** Compiles any supported expression. */
  export function compile(compiler: Compiler, node: typescript.Expression, contextualType: reflection.Type): binaryen.Expression;
}

declare module 'assemblyscript/library' {
  /** AssemblyScript version. */
  export const version: string;
  /** Library sources for in-browser usage. */
  export const files: {
    [key: string]: string;
  };
  /** Precompiled memory management runtime as a base64-encoded string. */
  export const runtime: string;
}

declare module 'assemblyscript/profiler' {
  /** A simple profiler used to measure compilation times. */
  export class Profiler {
      /** Cached labels. */
      labels: {
          [key: string]: number;
      };
      /**
        * Starts measuring using the specified label.
        * @param label Label
        */
      start(label: string): void;
      /**
        * Ends measuring using the specified label.
        * @param label Label
        * @returns High resolution time span in milliseconds
        */
      end(label: string): number;
  }
  export { Profiler as default };
}

declare module 'assemblyscript/reflection' {
  /**
    * Reflection components representing the WebAssembly output.
    * @module assemblyscript/reflection
    * @preferred
    */ /** */
  export * from "assemblyscript/reflection/class";
  export * from "assemblyscript/reflection/enum";
  export * from "assemblyscript/reflection/function";
  export * from "assemblyscript/reflection/property";
  export * from "assemblyscript/reflection/type";
  export * from "assemblyscript/reflection/variable";
  import * as reflection from "assemblyscript/reflection";
  /** Union type of concrete reflection objects. */
  export type Object = reflection.Variable | reflection.Enum | reflection.Function | reflection.FunctionTemplate | reflection.Class | reflection.ClassTemplate;
  /** Filter flags for resolving specific reflection objects only. */
  export enum ObjectFlags {
      /** Accept variables. */
      Variable = 1,
      /** Accept enums. */
      Enum = 2,
      /** Accept class instances. */
      Class = 4,
      /** Accept class templates.  */
      ClassTemplate = 8,
      /** Accept function instances. */
      Function = 16,
      /** Accept function templates. */
      FunctionTemplate = 32,
      /** Accepts function instances and templates. */
      FunctionInclTemplate = 48,
      /** Accepts class instances and templates. */
      ClassInclTemplate = 12,
      /** Accepts any valid property parent. */
      AnyPropertyParent = 6,
      /** Accepts any reflection object. */
      Any = -1,
  }
}

declare module 'assemblyscript/typescript' {
  import * as ts from "assemblyscript/--/lib/typescript/build";
  export import ArrayLiteralExpression = ts.ArrayLiteralExpression;
  export import ArrayTypeNode = ts.ArrayTypeNode;
  export import AsExpression = ts.AsExpression;
  export import BinaryExpression = ts.BinaryExpression;
  export import Block = ts.Block;
  export import BreakStatement = ts.BreakStatement;
  export import CallExpression = ts.CallExpression;
  export import ClassDeclaration = ts.ClassDeclaration;
  import CompilerHost = ts.CompilerHost;
  export import ConditionalExpression = ts.ConditionalExpression;
  export import ConstructorDeclaration = ts.ConstructorDeclaration;
  export import ContinueStatement = ts.ContinueStatement;
  export import DiagnosticCategory = ts.DiagnosticCategory;
  export import DiagnosticCollection = ts.DiagnosticCollection;
  export import DiagnosticMessage = ts.DiagnosticMessage;
  export import Diagnostic = ts.Diagnostic;
  export import DoStatement = ts.DoStatement;
  export import ElementAccessExpression = ts.ElementAccessExpression;
  export import EnumDeclaration = ts.EnumDeclaration;
  export import EnumMember = ts.EnumMember;
  export import EntityName = ts.EntityName;
  export import ExpressionStatement = ts.ExpressionStatement;
  export import Expression = ts.Expression;
  import FormatDiagnosticsHost = ts.FormatDiagnosticsHost;
  export import ForStatement = ts.ForStatement;
  export import FunctionBody = ts.FunctionBody;
  export import FunctionLikeDeclaration = ts.FunctionLikeDeclaration;
  export import FunctionDeclaration = ts.FunctionDeclaration;
  export import GetAccessorDeclaration = ts.GetAccessorDeclaration;
  export import Identifier = ts.Identifier;
  export import IfStatement = ts.IfStatement;
  export import LiteralExpression = ts.LiteralExpression;
  export import MethodDeclaration = ts.MethodDeclaration;
  export import ModifierFlags = ts.ModifierFlags;
  export import NewExpression = ts.NewExpression;
  export import NodeArray = ts.NodeArray;
  export import NodeFlags = ts.NodeFlags;
  export import Node = ts.Node;
  export import NumericLiteral = ts.NumericLiteral;
  export import OmittedExpression = ts.OmittedExpression;
  export import ParameterDeclaration = ts.ParameterDeclaration;
  export import ParenthesizedExpression = ts.ParenthesizedExpression;
  export import PostfixUnaryExpression = ts.PostfixUnaryExpression;
  export import PrefixUnaryExpression = ts.PrefixUnaryExpression;
  export import Program = ts.Program;
  export import PropertyAccessExpression = ts.PropertyAccessExpression;
  export import PropertyDeclaration = ts.PropertyDeclaration;
  export import Signature = ts.Signature;
  export import TypeAliasDeclaration = ts.TypeAliasDeclaration;
  export import TypeChecker = ts.TypeChecker;
  export import TypeNode = ts.TypeNode;
  export import TypeParameterDeclaration = ts.TypeParameterDeclaration;
  export import TypeReferenceNode = ts.TypeReferenceNode;
  export import TypeReference = ts.TypeReference;
  export import Type = ts.Type;
  export import VariableDeclaration = ts.VariableDeclaration;
  export import VariableDeclarationList = ts.VariableDeclarationList;
  export import VariableStatement = ts.VariableStatement;
  export import ReturnStatement = ts.ReturnStatement;
  export import ScriptTarget = ts.ScriptTarget;
  export import SetAccessorDeclaration = ts.SetAccessorDeclaration;
  export import SourceFile = ts.SourceFile;
  export import Statement = ts.Statement;
  export import SwitchStatement = ts.SwitchStatement;
  export import Symbol = ts.Symbol;
  export import SyntaxKind = ts.SyntaxKind;
  export import WhileStatement = ts.WhileStatement;
  export import getPreEmitDiagnostics = ts.getPreEmitDiagnostics;
  export import getSourceFileOfNode = ts.getSourceFileOfNode;
  export import getTextOfNode = ts.getTextOfNode;
  export import isDeclaration = ts.isDeclaration;
  export import createDiagnosticCollection = ts.createDiagnosticCollection;
  export import createDiagnosticForNode = ts.createDiagnosticForNode;
  export import createProgram = ts.createProgram;
  export import createSourceFile = ts.createSourceFile;
  export import createNodeArray = ts.createNodeArray;
  export { DiagnosticsEx } from "assemblyscript/typescript/diagnosticMessages.generated";
  /** Default format diagnostics host for convenience. */
  export const defaultFormatDiagnosticsHost: FormatDiagnosticsHost;
  /** Default compiler options for AssemblyScript compilation. */
  export const defaultCompilerOptions: ts.CompilerOptions;
  /** Creates an AssemblyScript-compatible compiler host. */
  export function createCompilerHost(moduleSearchLocations: string[], entryFileSource?: string, entryFileName?: string): CompilerHost;
  /** Formats a diagnostic message in plain text. */
  export function formatDiagnostics(diagnostics: Diagnostic[], host?: FormatDiagnosticsHost): string;
  /** Formats a diagnostic message with terminal colors and source context. */
  export function formatDiagnosticsWithColorAndContext(diagnostics: Diagnostic[], host?: FormatDiagnosticsHost): string;
  /** Prints a diagnostic message to console. */
  export function printDiagnostic(diagnostic: Diagnostic): void;
}

declare module 'assemblyscript/statements' {
  /**
    * Compiler components dealing with TypeScript statements.
    * @module assemblyscript/statements
    * @preferred
    */ /** */
  export * from "assemblyscript/statements/block";
  export * from "assemblyscript/statements/break";
  export * from "assemblyscript/statements/do";
  export * from "assemblyscript/statements/empty";
  export * from "assemblyscript/statements/expression";
  export * from "assemblyscript/statements/for";
  export * from "assemblyscript/statements/if";
  export * from "assemblyscript/statements/return";
  export * from "assemblyscript/statements/switch";
  export * from "assemblyscript/statements/variable";
  export * from "assemblyscript/statements/while";
  import * as binaryen from "binaryen";
  import Compiler from "assemblyscript/compiler";
  import * as typescript from "assemblyscript/typescript";
  /** Compiles any supported statement. */
  export function compile(compiler: Compiler, node: typescript.Statement): binaryen.Statement;
}

declare module 'assemblyscript/util' {
  /**
    * Utility functions.
    * @module assemblyscript/util
    */ /** */
  import * as typescript from "assemblyscript/typescript";
  import * as reflection from "assemblyscript/reflection";
  import * as wabt from "wabt";
  /** Tests if the specified node, or optionally either its parent, has an 'export' modifier. */
  export function isExport(node: typescript.Node, checkParent?: boolean): boolean;
  /** Tests if the specified node, or optionally either its parent, has a 'declare' modifier. */
  export function isDeclare(node: typescript.Node, checkParent?: boolean): boolean;
  /** Tests if the specified node has a 'static' modifier or is otherwise part of a static context. */
  export function isStatic(node: typescript.Node): boolean;
  /** Tests if the specified node has an 'abstract' modifier. */
  export function isAbstract(node: typescript.Node): boolean;
  /** Tests if the specified node is flagged 'const'. */
  export function isConst(node: typescript.Node): boolean;
  /** Gets the reflected type of an expression. */
  export function getReflectedType(node: typescript.Expression): reflection.Type;
  /** Sets the reflected type of an expression. */
  export function setReflectedType(node: typescript.Expression, type: reflection.Type): void;
  /** Gets the reflected function instance (describing a function with generic types resolved) of a function declaration. */
  export function getReflectedFunction(node: typescript.FunctionLikeDeclaration): reflection.Function;
  /** Sets the reflected function instance (describing a function with generic types resolved) of a function declaration. */
  export function setReflectedFunction(node: typescript.FunctionLikeDeclaration, instance: reflection.Function): void;
  /** Gets the reflected function template (describing a function with unresolved generic types) of a function declaration. */
  export function getReflectedFunctionTemplate(node: typescript.FunctionLikeDeclaration): reflection.FunctionTemplate;
  /** Sets the reflected function template (describing a function with unresolved generic types) of a function declaration. */
  export function setReflectedFunctionTemplate(node: typescript.FunctionLikeDeclaration, template: reflection.FunctionTemplate): void;
  /** Gets the reflected class instance (describing a class with generic types resolved) of a class declaration. */
  export function getReflectedClass(node: typescript.ClassDeclaration): reflection.Class;
  /** Sets the reflected class instance (describing a class with generic types resolved) of a class declaration. */
  export function setReflectedClass(node: typescript.ClassDeclaration, instance: reflection.Class): void;
  /** Gets the reflected class template (describing a class with unresolved generic types) of a class declaration. */
  export function getReflectedClassTemplate(node: typescript.ClassDeclaration): reflection.ClassTemplate;
  /** Sets the reflected class template (describing a class with unresolved generic types) of a class declaration. */
  export function setReflectedClassTemplate(node: typescript.ClassDeclaration, template: reflection.ClassTemplate): void;
  /** wabt.js, if available. */
  export import wabt = wabt;
  /** Options for {@link wasmToWast}. */
  export interface WasmToWastOptions {
      readDebugNames?: boolean;
      foldExprs?: boolean;
      inlineExport?: boolean;
      generateNames?: boolean;
  }
  /** Converts a WebAssembly binary to text format using linear syntax. Requires wabt.js to be present. */
  export function wasmToWast(buffer: Uint8Array, options?: WasmToWastOptions): string;
  /** Options for {@link wastToWasm}. */
  export interface WastToWasmOptions {
      filename?: string;
      canonicalizeLebs?: boolean;
      relocatable?: boolean;
      writeDebugNames?: boolean;
  }
  /** Converts WebAssembly text format using linear syntax to a binary. Requires wabt.js to be present. */
  export function wastToWasm(text: string, options?: WastToWasmOptions): Uint8Array;
}

declare module 'assemblyscript/expressions/arrayliteral' {
  /** @module assemblyscript/expressions */ /** */
  import * as binaryen from "binaryen";
  import Compiler from "assemblyscript/compiler";
  import * as reflection from "assemblyscript/reflection";
  import * as typescript from "assemblyscript/typescript";
  /** Compiles an array literal expression. */
  export function compileArrayLiteral(compiler: Compiler, node: typescript.ArrayLiteralExpression, contextualType: reflection.Type): binaryen.Expression;
}

declare module 'assemblyscript/expressions/as' {
  /** @module assemblyscript/expressions */ /** */
  import * as binaryen from "binaryen";
  import Compiler from "assemblyscript/compiler";
  import * as reflection from "assemblyscript/reflection";
  import * as typescript from "assemblyscript/typescript";
  /** Compiles an 'as' expression explicitly converting from one type to another. */
  export function compileAs(compiler: Compiler, node: typescript.AsExpression, contextualType: reflection.Type): binaryen.Expression;
  export { compileAs as default };
}

declare module 'assemblyscript/expressions/binary' {
  /** @module assemblyscript/expressions */ /** */
  import * as binaryen from "binaryen";
  import Compiler from "assemblyscript/compiler";
  import * as reflection from "assemblyscript/reflection";
  import * as typescript from "assemblyscript/typescript";
  /** Compiles a binary expression. Covers addition, multiplication and so on. */
  export function compileBinary(compiler: Compiler, node: typescript.BinaryExpression, contextualType: reflection.Type): binaryen.Expression;
  export { compileBinary as default };
  /** Compiles a binary assignment expression. */
  export function compileAssignment(compiler: Compiler, node: typescript.BinaryExpression, contextualType: reflection.Type): binaryen.Expression;
  /** Compiles a binary assignment expression with a pre-computed value. */
  export function compileAssignmentWithValue(compiler: Compiler, node: typescript.BinaryExpression, value: binaryen.Expression, contextualType: reflection.Type): binaryen.Expression;
  /** Compiles a binary logical AND or OR expression. */
  export function compileLogicalAndOr(compiler: Compiler, node: typescript.BinaryExpression): binaryen.Expression;
  /** Compiles any expression so that it evaluates to a boolean result indicating whether it is true-ish. */
  export function compileIsTrueish(compiler: Compiler, node: typescript.Expression): binaryen.Expression;
}

declare module 'assemblyscript/expressions/call' {
  /** @module assemblyscript/expressions */ /** */
  import * as binaryen from "binaryen";
  import Compiler from "assemblyscript/compiler";
  import * as typescript from "assemblyscript/typescript";
  /** Compiles a function call expression. */
  export function compileCall(compiler: Compiler, node: typescript.CallExpression): binaryen.Expression;
  export { compileCall as default };
}

declare module 'assemblyscript/expressions/conditional' {
  /** @module assemblyscript/expressions */ /** */
  import * as binaryen from "binaryen";
  import Compiler from "assemblyscript/compiler";
  import * as reflection from "assemblyscript/reflection";
  import * as typescript from "assemblyscript/typescript";
  /** Compiles a conditional (ternary) expression. */
  export function compileConditional(compiler: Compiler, node: typescript.ConditionalExpression, contextualType: reflection.Type): binaryen.Expression;
  export { compileConditional as default };
}

declare module 'assemblyscript/expressions/elementaccess' {
  /** @module assemblyscript/expressions */ /** */
  import * as binaryen from "binaryen";
  import Compiler from "assemblyscript/compiler";
  import * as reflection from "assemblyscript/reflection";
  import * as typescript from "assemblyscript/typescript";
  /** Compiles an element access expression. Sets the element's value to `valueNode` if specified, otherwise gets it. */
  export function compileElementAccess(compiler: Compiler, node: typescript.ElementAccessExpression, contextualType: reflection.Type, valueNode?: typescript.Expression): binaryen.Expression;
  export { compileElementAccess as default };
}

declare module 'assemblyscript/expressions/helpers/load' {
  /** @module assemblyscript/expressions */ /** */
  import * as binaryen from "binaryen";
  import Compiler from "assemblyscript/compiler";
  import * as reflection from "assemblyscript/reflection";
  import * as typescript from "assemblyscript/typescript";
  /** Helper compiling a load operation. */
  export function compileLoad(compiler: Compiler, node: typescript.Expression, type: reflection.Type, ptr: binaryen.Expression, offset: number): binaryen.Expression;
  export { compileLoad as default };
}

declare module 'assemblyscript/expressions/helpers/loadorstore' {
  /** @module assemblyscript/expressions */ /** */
  import * as binaryen from "binaryen";
  import Compiler from "assemblyscript/compiler";
  import * as reflection from "assemblyscript/reflection";
  import * as typescript from "assemblyscript/typescript";
  /** Helper compiling a load operation if `valueToSet` has been omitted, otherwise a store operation. */
  export function compileLoadOrStore(compiler: Compiler, node: typescript.Expression, type: reflection.Type, ptr: binaryen.Expression, offset: number, valueToSet?: binaryen.Expression, valueToSetContextualType?: reflection.Type): binaryen.Expression;
  export { compileLoadOrStore as default };
}

declare module 'assemblyscript/expressions/helpers/store' {
  /** @module assemblyscript/expressions */ /** */
  import * as binaryen from "binaryen";
  import Compiler from "assemblyscript/compiler";
  import * as reflection from "assemblyscript/reflection";
  import * as typescript from "assemblyscript/typescript";
  /** Helper compiling a store operation. */
  export function compileStore(compiler: Compiler, node: typescript.Expression, type: reflection.Type, ptr: binaryen.Expression, offset: number, value: binaryen.Expression): binaryen.Expression;
  export { compileStore as default };
}

declare module 'assemblyscript/expressions/identifier' {
  /** @module assemblyscript/expressions */ /** */
  import * as binaryen from "binaryen";
  import Compiler from "assemblyscript/compiler";
  import * as reflection from "assemblyscript/reflection";
  import * as typescript from "assemblyscript/typescript";
  /** Compiles an identifier expression. */
  export function compileIdentifier(compiler: Compiler, node: typescript.Identifier, contextualType: reflection.Type): binaryen.Expression;
  export { compileIdentifier as default };
}

declare module 'assemblyscript/expressions/literal' {
  /** @module assemblyscript/expressions */ /** */
  import * as binaryen from "binaryen";
  import Compiler from "assemblyscript/compiler";
  import * as reflection from "assemblyscript/reflection";
  import * as typescript from "assemblyscript/typescript";
  /** Compiles a literal expression. */
  export function compileLiteral(compiler: Compiler, node: typescript.LiteralExpression, contextualType: reflection.Type, negate?: boolean): binaryen.Expression;
  export { compileLiteral as default };
}

declare module 'assemblyscript/expressions/new' {
  /** @module assemblyscript/expressions */ /** */
  import * as binaryen from "binaryen";
  import Compiler from "assemblyscript/compiler";
  import * as reflection from "assemblyscript/reflection";
  import * as typescript from "assemblyscript/typescript";
  /** Compiles a 'new' expression. */
  export function compileNew(compiler: Compiler, node: typescript.NewExpression, contextualType: reflection.Type): binaryen.Expression;
  export { compileNew as default };
}

declare module 'assemblyscript/expressions/omitted' {
  /** @module assemblyscript/expressions */ /** */
  import * as binaryen from "binaryen";
  import Compiler from "assemblyscript/compiler";
  import * as reflection from "assemblyscript/reflection";
  import * as typescript from "assemblyscript/typescript";
  /** Compiles an omitted expression. */
  export function compileOmitted(compiler: Compiler, node: typescript.OmittedExpression, contextualType: reflection.Type): binaryen.Expression;
  export { compileOmitted as default };
}

declare module 'assemblyscript/expressions/parenthesized' {
  /** @module assemblyscript/expressions */ /** */
  import * as binaryen from "binaryen";
  import Compiler from "assemblyscript/compiler";
  import * as reflection from "assemblyscript/reflection";
  import * as typescript from "assemblyscript/typescript";
  /** Compiles a parenthesized expression. */
  export function compileParenthesized(compiler: Compiler, node: typescript.ParenthesizedExpression, contextualType: reflection.Type): binaryen.Expression;
  export { compileParenthesized as default };
}

declare module 'assemblyscript/expressions/postfixunary' {
  /** @module assemblyscript/expressions */ /** */
  import * as binaryen from "binaryen";
  import Compiler from "assemblyscript/compiler";
  import * as reflection from "assemblyscript/reflection";
  import * as typescript from "assemblyscript/typescript";
  /** Compiles a unary postfix expression. */
  export function compilePostfixUnary(compiler: Compiler, node: typescript.PostfixUnaryExpression, contextualType: reflection.Type): binaryen.Expression;
  export { compilePostfixUnary as default };
}

declare module 'assemblyscript/expressions/prefixunary' {
  /** @module assemblyscript/expressions */ /** */
  import * as binaryen from "binaryen";
  import Compiler from "assemblyscript/compiler";
  import * as reflection from "assemblyscript/reflection";
  import * as typescript from "assemblyscript/typescript";
  /** Compiles a unary prefix expression. */
  export function compilePrefixUnary(compiler: Compiler, node: typescript.PrefixUnaryExpression, contextualType: reflection.Type): binaryen.Expression;
  export { compilePrefixUnary as default };
}

declare module 'assemblyscript/expressions/propertyaccess' {
  /** @module assemblyscript/expressions */ /** */
  import * as binaryen from "binaryen";
  import Compiler from "assemblyscript/compiler";
  import * as reflection from "assemblyscript/reflection";
  import * as typescript from "assemblyscript/typescript";
  /** Compiles a property access expression. Sets the property's value to `valueNode` if specified, otherwise gets it. */
  export function compilePropertyAccess(compiler: Compiler, node: typescript.PropertyAccessExpression, contextualType: reflection.Type, valueNode?: typescript.Expression): binaryen.Expression;
  export { compilePropertyAccess as default };
}

declare module 'assemblyscript/reflection/class' {
  /** @module assemblyscript/reflection */ /** */
  import Compiler from "assemblyscript/compiler";
  import { FunctionTemplate, Function } from "assemblyscript/reflection/function";
  import Property from "assemblyscript/reflection/property";
  import { Type, TypeArgumentsMap } from "assemblyscript/reflection/type";
  import * as typescript from "assemblyscript/typescript";
  /** Common base class of {@link Class} and {@link ClassTemplate}. */
  export abstract class ClassBase {
      /** Compiler reference. */
      compiler: Compiler;
      /** Global name. */
      name: string;
      /** Simple name. */
      simpleName: string;
      /** Declaration reference. */
      declaration: typescript.ClassDeclaration;
      protected constructor(compiler: Compiler, name: string, declaration: typescript.ClassDeclaration);
      /** Tests if this class is generic. */
      readonly isGeneric: boolean;
      /** Tests if this class is exported. */
      readonly isExport: boolean;
      /** Tests if this class has been annotated with a decorator of the specified name. */
      hasDecorator(name: string): boolean;
      toString(): string;
  }
  /** Interface describing a reflected class method. */
  export interface ClassMethod {
      /** Class template with possibly unresolved type parameters. */
      template: FunctionTemplate;
      /** Class instance with type parameters resolved, if initialized yet. */
      instance?: Function;
  }
  /** Tests if the specified global name references a built-in array. */
  export function isBuiltinArray(globalName: string): boolean;
  /** Tests if the specified global name references a built-in string. */
  export function isBuiltinString(globalName: string): boolean;
  /** A class handle consisting of its instance, if any, and its template. */
  export interface ClassHandle {
      template: ClassTemplate;
      instance?: Class;
  }
  /** A class instance with generic parameters resolved. */
  export class Class extends ClassBase {
      /** Corresponding class template. */
      template: ClassTemplate;
      /** Reflected class type. */
      type: Type;
      /** Concrete type arguments. */
      typeArguments: typescript.NodeArray<typescript.TypeNode> | typescript.TypeNode[];
      /** Type arguments map. */
      typeArgumentsMap: TypeArgumentsMap;
      /** Base class, if any. */
      base?: Class;
      /** Static and instance class properties. */
      properties: {
          [key: string]: Property;
      };
      /** Static and instance class methods. */
      methods: {
          [key: string]: ClassMethod;
      };
      /** Getter methods. */
      getters: {
          [key: string]: ClassMethod;
      };
      /** Setter methods. */
      setters: {
          [key: string]: ClassMethod;
      };
      /** Class constructor, if any. */
      ctor?: Function;
      /** Size in memory, in bytes. */
      size: number;
      /** Whether array access is supported on this class. */
      isArray: boolean;
      /** Whether this is a string-like class. */
      isString: boolean;
      /** Whether memory must be allocated implicitly. */
      implicitMalloc: boolean;
      /** Constructs a new reflected class and binds it to its TypeScript declaration. */
      constructor(compiler: Compiler, name: string, template: ClassTemplate, typeArguments: typescript.NodeArray<typescript.TypeNode> | typescript.TypeNode[], base?: Class);
      /** Tests if this class extends another class. */
      extends(base: Class): boolean;
      /** Tests if this class is assignable to the specified (class) type. */
      isAssignableTo(type: Class): boolean;
  }
  export { Class as default };
  /** A class template with possibly unresolved generic parameters. */
  export class ClassTemplate extends ClassBase {
      /** Class instances by global name. */
      instances: {
          [key: string]: Class;
      };
      /** Base class template, if any. */
      base?: ClassTemplate;
      /** Base type arguments. */
      baseTypeArguments: typescript.NodeArray<typescript.TypeNode> | typescript.TypeNode[];
      /** Static and instance class property declarations by simple name. */
      propertyDeclarations: {
          [key: string]: typescript.PropertyDeclaration;
      };
      /** Static and instance method declarations by simple name. */
      methodDeclarations: {
          [key: string]: typescript.MethodDeclaration;
      };
      /** Getter declarations by simple name. */
      getterDeclarations: {
          [key: string]: typescript.MethodDeclaration;
      };
      /** Setter declarations by simple name. */
      setterDeclarations: {
          [key: string]: typescript.MethodDeclaration;
      };
      /** Constructor declaration, if any. */
      ctorDeclaration?: typescript.ConstructorDeclaration;
      /** Constructs a new reflected class template and binds it to its declaration. */
      constructor(compiler: Compiler, name: string, declaration: typescript.ClassDeclaration, base?: ClassTemplate, baseTypeArguments?: typescript.NodeArray<typescript.TypeNode> | typescript.TypeNode[]);
      /** Resolves this possibly generic class against the provided type arguments. */
      resolve(typeArgumentNodes: typescript.NodeArray<typescript.TypeNode> | typescript.TypeNode[], typeArgumentsMap?: TypeArgumentsMap): Class;
  }
  /** Patches a declaration to inherit from its actual implementation. */
  export function patchClassImplementation(declTemplate: ClassTemplate, implTemplate: ClassTemplate): void;
}

declare module 'assemblyscript/reflection/enum' {
  /** @module assemblyscript/reflection */ /** */
  import Compiler from "assemblyscript/compiler";
  import Property from "assemblyscript/reflection/property";
  import * as typescript from "assemblyscript/typescript";
  /** A reflected enum instance. */
  export class Enum {
      /** Compiler reference. */
      compiler: Compiler;
      /** Global name. */
      name: string;
      /** Simple name. */
      simpleName: string;
      /** Declaration reference. */
      declaration: typescript.EnumDeclaration;
      /** Enum values by simple name. */
      values: {
          [key: string]: Property;
      };
      /** Constructs a new reflected enum and binds it to its TypeScript declaration. */
      constructor(compiler: Compiler, name: string, declaration: typescript.EnumDeclaration);
      toString(): string;
  }
  export { Enum as default };
}

declare module 'assemblyscript/reflection/function' {
  /** @module assemblyscript/reflection */ /** */
  import * as binaryen from "binaryen";
  import { Class } from "assemblyscript/reflection/class";
  import Compiler from "assemblyscript/compiler";
  import { Type, TypeArgumentsMap } from "assemblyscript/reflection/type";
  import { Variable } from "assemblyscript/reflection/variable";
  import * as typescript from "assemblyscript/typescript";
  /** A function handle consisting of its instance, if any, and its template. */
  export interface FunctionHandle {
      template: FunctionTemplate;
      instance?: Function;
  }
  /** Common base class of {@link Function} and {@link FunctionTemplate}. */
  export abstract class FunctionBase {
      /** Compiler reference. */
      compiler: Compiler;
      /** Global name. */
      name: string;
      /** Simple name. */
      simpleName: string;
      /** Declaration reference. */
      declaration: typescript.FunctionLikeDeclaration;
      /** Class declaration reference, if any. */
      classDeclaration?: typescript.ClassDeclaration;
      protected constructor(compiler: Compiler, name: string, declaration: typescript.FunctionLikeDeclaration);
      /** Tests if this function is an import. */
      readonly isImport: boolean;
      /** Tests if this function is exported. */
      readonly isExport: boolean;
      /** Tests if this function is an instance member / not static. */
      readonly isInstance: boolean;
      /** Tests if this function is the constructor of a class. */
      readonly isConstructor: boolean;
      /** Tests if this function is a getter. */
      readonly isGetter: boolean;
      /** Tests if this function is a setter. */
      readonly isSetter: boolean;
      /** Tests if this function is generic. */
      readonly isGeneric: boolean;
      toString(): string;
  }
  /** Interface describing a reflected function parameter. */
  export interface FunctionParameter {
      /** Simple name. */
      name: string;
      /** Resolved type. */
      type: Type;
      /** Parameter node reference. */
      node: typescript.Node;
      /** Whether this parameter also introduces a property (like when used with the `public` keyword). */
      isAlsoProperty?: boolean;
      /** Optional value initializer. */
      initializer?: typescript.Expression;
  }
  /** A function instance with generic parameters resolved. */
  export class Function extends FunctionBase {
      /** Internal name for use with call operations. */
      internalName: string;
      /** Corresponding function template. */
      template: FunctionTemplate;
      /** Concrete type arguments. */
      typeArguments: typescript.NodeArray<typescript.TypeNode> | typescript.TypeNode[];
      /** Resolved type arguments. */
      typeArgumentsMap: TypeArgumentsMap;
      /** Function parameters including `this`. */
      parameters: FunctionParameter[];
      /** Resolved return type. */
      returnType: Type;
      /** Parent class, if any. */
      parent?: Class;
      /** Body reference, if not just a declaration. */
      body?: typescript.Block | typescript.Expression;
      /** Current unique local id. */
      uniqueLocalId: 1;
      /** Local variables. */
      locals: Variable[];
      /** Local variables by name for lookups. */
      localsByName: {
          [key: string]: Variable;
      };
      /** Resolved binaryen parameter types. */
      binaryenParameterTypes: binaryen.Type[];
      /** Resolved binaryen return type. */
      binaryenReturnType: binaryen.Type;
      /** Binaryen signature id, for example "iiv". */
      binaryenSignatureId: string;
      /** Binaryen signature reference. */
      binaryenSignature: binaryen.Signature;
      /** Whether this function has already been compiled. */
      compiled: boolean;
      /** Whether this function has been imported. */
      imported: boolean;
      /** Number of the current break context. */
      breakNumber: number;
      /** Depth within the current break context. */
      breakDepth: number;
      /** Binaryen function reference. */
      binaryenFunction: binaryen.Function;
      /** Constructs a new reflected function instance and binds it to its TypeScript declaration. */
      constructor(compiler: Compiler, name: string, template: FunctionTemplate, typeArguments: typescript.NodeArray<typescript.TypeNode> | typescript.TypeNode[], typeArgumentsMap: TypeArgumentsMap, parameters: FunctionParameter[], returnType: Type, parent?: Class, body?: typescript.Block | typescript.Expression);
      /** Gets the current break label for use with binaryen loops and blocks. */
      readonly breakLabel: string;
      /** Introduces an additional local variable of the specified name and type. */
      addLocal(name: string, type: Type): Variable;
      /** Introduces an additional unique local variable of the specified type. */
      addUniqueLocal(type: Type, prefix?: string): Variable;
      /** Compiles a call to this function using the specified arguments. Arguments to instance functions include `this` as the first argument or can specifiy it in `thisArg`. */
      compileCall(argumentNodes: typescript.NodeArray<typescript.Expression> | typescript.Expression[], thisArg?: binaryen.Expression): binaryen.Expression;
      /** Makes a call to this function using the specified operands. */
      call(operands: binaryen.Expression[]): binaryen.Expression;
  }
  export { Function as default };
  /** A function template with possibly unresolved generic parameters. */
  export class FunctionTemplate extends FunctionBase {
      /** Declaration reference. */
      declaration: typescript.FunctionLikeDeclaration;
      /** So far resolved instances by global name. */
      instances: {
          [key: string]: Function;
      };
      /** Parent class, if any. */
      parent: Class | undefined;
      /** Constructs a new reflected function template and binds it to its TypeScript declaration. */
      constructor(compiler: Compiler, name: string, declaration: typescript.FunctionLikeDeclaration, parent?: Class);
      /** Resolves this possibly generic function against the provided type arguments. */
      resolve(typeArguments: typescript.NodeArray<typescript.TypeNode> | typescript.TypeNode[], typeArgumentsMap?: TypeArgumentsMap): Function;
  }
}

declare module 'assemblyscript/reflection/property' {
  /** @module assemblyscript/reflection */ /** */
  import Compiler from "assemblyscript/compiler";
  import Type from "assemblyscript/reflection/type";
  import * as typescript from "assemblyscript/typescript";
  /** A reflected property. Also used to describe enum values. */
  export class Property {
      /** Compiler reference. */
      compiler: Compiler;
      /** Global name. */
      name: string;
      /** Simple name. */
      simpleName: string;
      /** Declaration reference. */
      declaration: typescript.PropertyDeclaration | typescript.EnumMember;
      /** Resolved type. */
      type: Type;
      /** Offset in memory, if applicable. */
      offset: number;
      /** Initializer expression, if applicable. */
      initializer: typescript.Expression | undefined;
      /** Constructs a new reflected property. */
      constructor(compiler: Compiler, name: string, declaration: typescript.PropertyDeclaration | typescript.EnumMember, type: Type, offset: number, initializer?: typescript.Expression);
      /** Tests if this property is an instance member. */
      readonly isInstance: boolean;
      toString(): string;
  }
  export { Property as default };
}

declare module 'assemblyscript/reflection/type' {
  /** @module assemblyscript/reflection */ /** */
  import Class from "assemblyscript/reflection/class";
  import * as typescript from "assemblyscript/typescript";
  /** Core type kinds including range aliases. */
  export enum TypeKind {
      /** First integer of any size and signage. */
      FirstInteger = 0,
      /** First unsigned integer of any size. */
      FirstUnsigned = 0,
      /** Unsigned 8-bit integer type. */
      byte = 0,
      /** Unsigned 16-bit integer type. */
      ushort = 1,
      /** Unsigned 32-bit integer type. */
      uint = 2,
      /** Unsigned 64-bit integer type. */
      ulong = 3,
      /** Last unsigned integer of any size. */
      LastUnsigned = 4,
      /** Unsigned 32-/64-bit pointer type. */
      uintptr = 4,
      /** First signed integer of any size. */
      FirstSigned = 5,
      /** Signed 8-bit integer type. */
      sbyte = 5,
      /** Signed 16-bit integer type. */
      short = 6,
      /** Signed 32-bit integer type. */
      int = 7,
      /** Last signed integer of any size. */
      LastSigned = 8,
      /** Last integer of any size and signage. */
      LastInteger = 8,
      /** Signed 64-bit integer type. */
      long = 8,
      /** First float of any size. */
      FirstFloat = 9,
      /** 32-bit float type. */
      float = 9,
      /** Last float of any size. */
      LastFloat = 10,
      /** 64-bit float type. */
      double = 10,
      /** Bool type. */
      bool = 11,
      /** Void type. */
      void = 12,
  }
  /** A reflected type. */
  export class Type {
      /** Type kind. */
      kind: TypeKind;
      /** Size in linear memory. */
      size: number;
      /** The underlying class, if a pointer. */
      underlyingClass?: Class;
      /** Constructs a new reflected type. Not meant to introduce any types other than the core types. */
      constructor(kind: TypeKind, size: number, underlyingClass?: Class);
      /** Tests if this is an integer type of any size. */
      readonly isAnyInteger: boolean;
      /** Tests if this is a float type of any size. */
      readonly isAnyFloat: boolean;
      /** Tests if this is a signed integer type of any size. */
      readonly isSigned: boolean;
      /** Tests if this is an 8-bit integer type of any signage. */
      readonly isByte: boolean;
      /** Tests if this is a 16-bit integer type of any signage. */
      readonly isShort: boolean;
      /** Tests if this is a 32-bit integer type of any signage. */
      readonly isInt: boolean;
      /** Tests if this is a 64-bit integer type of any signage. */
      readonly isLong: boolean;
      /** Tests if this is a pointer with an underlying class. */
      readonly isClass: boolean;
      /** Tests if this is a pointer with an underlying array-like class. */
      readonly isArray: boolean;
      /** Tests if this is a pointer with an underlying string-like class. */
      readonly isString: boolean;
      /** Gets the common name of a temporary variable of this type. */
      readonly tempName: string;
      /** Amends a pointer to reference the specified underlying class. */
      withUnderlyingClass(underlyingClass: Class): Type;
      toString(): string;
  }
  export { Type as default };
  /** Reflected signed 8-bit integer type. */
  export const sbyteType: Type;
  /** Reflected unsigned 8-bit integer type. */
  export const byteType: Type;
  /** Reflected signed 16-bit integer type. */
  export const shortType: Type;
  /** Reflected unsigned 16-bit integer type. */
  export const ushortType: Type;
  /** Reflected signed 32-bit integer type. */
  export const intType: Type;
  /** Reflected unsigned 32-bit integer type. */
  export const uintType: Type;
  /** Reflected signed 64-bit integer type. */
  export const longType: Type;
  /** Reflected unsigned 64-bit integer type. */
  export const ulongType: Type;
  /** Reflected 32-bit float type. */
  export const floatType: Type;
  /** Reflected 64-bit float type. */
  export const doubleType: Type;
  /** Reflected 32-bit pointer type. Relevant only when compiling for 32-bit WebAssembly. */
  export const uintptrType32: Type;
  /** Reflected 64-bit pointer type. Relevant only when compiling for 64-bit WebAssembly. */
  export const uintptrType64: Type;
  /** Reflected bool type. */
  export const boolType: Type;
  /** Reflected void type. */
  export const voidType: Type;
  /** Interface describing a reflected type argument. */
  export interface TypeArgument {
      /** Reflected type. */
      type: Type;
      /** TypeScript type node. */
      node: typescript.TypeNode;
  }
  /** Interface describing a reflected type arguments map. */
  export interface TypeArgumentsMap {
      [key: string]: TypeArgument;
  }
}

declare module 'assemblyscript/reflection/variable' {
  /** @module assemblyscript/reflection */ /** */
  import Compiler from "assemblyscript/compiler";
  import Type from "assemblyscript/reflection/type";
  /** Flags describing the kind of a variable. */
  export enum VariableFlags {
      /** No flags. */
      none = 0,
      /** Constant variable. */
      constant = 1,
      /** Global variable. */
      global = 2,
  }
  /** A reflected variable. */
  export class Variable {
      /** Compiler reference. */
      compiler: Compiler;
      /** Simple or global name, depending on context. */
      name: string;
      /** Reflected type. */
      type: Type;
      /** Flags. */
      flags: VariableFlags;
      /** Local index, if applicable. */
      index: number;
      /** Constant value, if applicable. */
      value?: number | Long;
      /** Constructs a new reflected variable. */
      constructor(compiler: Compiler, name: string, type: Type, flags: VariableFlags, index: number, value?: number | Long);
      /** Tests if this variable is declared constant. */
      readonly isConstant: boolean;
      /** Tests if this is a global variable. */
      readonly isGlobal: boolean;
      toString(): string;
  }
  export { Variable as default };
}

declare module 'assemblyscript/typescript/diagnosticMessages.generated' {
  /** @module assemblyscript/typescript */ /** */
  import { DiagnosticCategory } from "assemblyscript/typescript";
  /** AssemblyScript specific diagnostic messages. */
  export const DiagnosticsEx: {
      Unsupported_node_kind_0_in_1: {
          code: number;
          category: DiagnosticCategory;
          key: string;
          message: string;
      };
      Unsupported_modifier_0: {
          code: number;
          category: DiagnosticCategory;
          key: string;
          message: string;
      };
      Unsupported_literal_0: {
          code: number;
          category: DiagnosticCategory;
          key: string;
          message: string;
      };
      Type_expected: {
          code: number;
          category: DiagnosticCategory;
          key: string;
          message: string;
      };
      Unresolvable_type_0: {
          code: number;
          category: DiagnosticCategory;
          key: string;
          message: string;
      };
      Unresolvable_identifier_0: {
          code: number;
          category: DiagnosticCategory;
          key: string;
          message: string;
      };
      Start_function_has_already_been_defined: {
          code: number;
          category: DiagnosticCategory;
          key: string;
          message: string;
      };
      Start_function_already_defined_here: {
          code: number;
          category: DiagnosticCategory;
          key: string;
          message: string;
      };
      Conversion_from_0_to_1_requires_an_explicit_cast: {
          code: number;
          category: DiagnosticCategory;
          key: string;
          message: string;
      };
      Conversion_from_0_to_1_will_fail_when_switching_between_WASM32_64: {
          code: number;
          category: DiagnosticCategory;
          key: string;
          message: string;
      };
      Type_0_is_invalid_in_this_context: {
          code: number;
          category: DiagnosticCategory;
          key: string;
          message: string;
      };
      Identifier_0_is_invalid_in_this_context: {
          code: number;
          category: DiagnosticCategory;
          key: string;
          message: string;
      };
      Assuming_0_instead_of_1: {
          code: number;
          category: DiagnosticCategory;
          key: string;
          message: string;
      };
      Assuming_return_type_0: {
          code: number;
          category: DiagnosticCategory;
          key: string;
          message: string;
      };
      Assuming_variable_type_0: {
          code: number;
          category: DiagnosticCategory;
          key: string;
          message: string;
      };
      Types_0_and_1_are_incompatible: {
          code: number;
          category: DiagnosticCategory;
          key: string;
          message: string;
      };
      Literal_overflow_Compiling_to_a_value_in_range_0_to_1_instead: {
          code: number;
          category: DiagnosticCategory;
          key: string;
          message: string;
      };
      Optional_parameters_must_specify_an_initializer: {
          code: number;
          category: DiagnosticCategory;
          key: string;
          message: string;
      };
      Unconditional_endless_loop_detected: {
          code: number;
          category: DiagnosticCategory;
          key: string;
          message: string;
      };
      Function_with_a_return_type_must_return_a_value: {
          code: number;
          category: DiagnosticCategory;
          key: string;
          message: string;
      };
      Function_without_a_return_type_cannot_return_a_value: {
          code: number;
          category: DiagnosticCategory;
          key: string;
          message: string;
      };
  };
  export { DiagnosticsEx as default };
}

declare module 'assemblyscript/statements/block' {
  /** @module assemblyscript/statements */ /** */
  import * as binaryen from "binaryen";
  import Compiler from "assemblyscript/compiler";
  import * as typescript from "assemblyscript/typescript";
  /** Compiles a block statement. */
  export function compileBlock(compiler: Compiler, node: typescript.Block): binaryen.Statement;
  export { compileBlock as default };
}

declare module 'assemblyscript/statements/break' {
  /** @module assemblyscript/statements */ /** */
  import * as binaryen from "binaryen";
  import Compiler from "assemblyscript/compiler";
  import * as typescript from "assemblyscript/typescript";
  /** Compiles a break statement. */
  export function compileBreak(compiler: Compiler, node: typescript.BreakStatement | typescript.ContinueStatement): binaryen.Statement;
  export { compileBreak as default };
}

declare module 'assemblyscript/statements/do' {
  /** @module assemblyscript/statements */ /** */
  import * as binaryen from "binaryen";
  import Compiler from "assemblyscript/compiler";
  import * as typescript from "assemblyscript/typescript";
  /** Compiles a do loop statement. */
  export function compileDo(compiler: Compiler, node: typescript.DoStatement): binaryen.Statement;
  export { compileDo as default };
}

declare module 'assemblyscript/statements/empty' {
  /** @module assemblyscript/statements */ /** */
  import * as binaryen from "binaryen";
  import Compiler from "assemblyscript/compiler";
  /** Compiles an empty statement. */
  export function compileEmpty(compiler: Compiler): binaryen.Statement;
  export { compileEmpty as default };
}

declare module 'assemblyscript/statements/expression' {
  /** @module assemblyscript/statements */ /** */
  import * as binaryen from "binaryen";
  import Compiler from "assemblyscript/compiler";
  import * as typescript from "assemblyscript/typescript";
  /** Compiles an expression statement. */
  export function compileExpression(compiler: Compiler, node: typescript.ExpressionStatement): binaryen.Statement;
  export { compileExpression as default };
}

declare module 'assemblyscript/statements/for' {
  /** @module assemblyscript/statements */ /** */
  import * as binaryen from "binaryen";
  import Compiler from "assemblyscript/compiler";
  import * as typescript from "assemblyscript/typescript";
  /** Compiles a for loop statement. */
  export function compileFor(compiler: Compiler, node: typescript.ForStatement): binaryen.Statement;
  export { compileFor as default };
}

declare module 'assemblyscript/statements/if' {
  /** @module assemblyscript/statements */ /** */
  import * as binaryen from "binaryen";
  import Compiler from "assemblyscript/compiler";
  import * as typescript from "assemblyscript/typescript";
  /** Compiles an if statement. */
  export function compileIf(compiler: Compiler, node: typescript.IfStatement): binaryen.Statement;
  export { compileIf as default };
}

declare module 'assemblyscript/statements/return' {
  /** @module assemblyscript/statements */ /** */
  import * as binaryen from "binaryen";
  import Compiler from "assemblyscript/compiler";
  import * as typescript from "assemblyscript/typescript";
  /** Compiles a return statement. */
  export function compileReturn(compiler: Compiler, node: typescript.ReturnStatement): binaryen.Statement;
  export { compileReturn as default };
}

declare module 'assemblyscript/statements/switch' {
  /** @module assemblyscript/statements */ /** */
  import * as binaryen from "binaryen";
  import Compiler from "assemblyscript/compiler";
  import * as typescript from "assemblyscript/typescript";
  /** Compiles a switch statement. */
  export function compileSwitch(compiler: Compiler, node: typescript.SwitchStatement): binaryen.Statement;
  export { compileSwitch as default };
}

declare module 'assemblyscript/statements/variable' {
  /** @module assemblyscript/statements */ /** */
  import * as binaryen from "binaryen";
  import { Compiler } from "assemblyscript/compiler";
  import * as typescript from "assemblyscript/typescript";
  /** Compiles a variable declaration statement. */
  export function compileVariable(compiler: Compiler, node: typescript.VariableStatement): binaryen.Statement;
  export { compileVariable as default };
  /** Compiles a variable declaration list statement. */
  export function compileVariableDeclarationList(compiler: Compiler, node: typescript.VariableDeclarationList): binaryen.Statement;
}

declare module 'assemblyscript/statements/while' {
  /** @module assemblyscript/statements */ /** */
  import * as binaryen from "binaryen";
  import Compiler from "assemblyscript/compiler";
  import * as typescript from "assemblyscript/typescript";
  /** Compiles a while loop statement. */
  export function compileWhile(compiler: Compiler, node: typescript.WhileStatement): binaryen.Statement;
  export { compileWhile as default };
}

